<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script>
      window.__PUBLIC_PATH = "/";
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.ts"></script>
    <script>
      window.MwdHelpers = {
        // Converts a file/folder path into query parameters for navigation
        fileItemQueryParams: (item) => {
          const segs = (item?.path || '').split(':');
          const drive = segs.length === 4
            ? `:${segs.slice(1, 3).join(':')}:/`
            : item?.drive || '';
          const path = segs.length === 4
            ? segs.slice(3).join(':')
            : item?.path || '';

          // Remove leading slash from path
          const cleanPath = path.startsWith('/') ? path.substring(1) : path;

          if (item?.isFolder) {
            return { drive, folder: cleanPath };
          }

          const parts = cleanPath.split('/');
          return {
            drive,
            folder: parts.slice(0, -1).join('/'),
            file: parts[parts.length - 1]
          };
        },

        // Join parent path and child name with /
        joinPath: (parentPath, childName) => {
          if (!parentPath) return childName || '/';
          if (!childName) return parentPath || '/';

          // Remove leading slash from childName
          const cleanChild = childName.startsWith('/') ? childName.substring(1) : childName;

          const res = parentPath.endsWith('/')
            ? parentPath + cleanChild
            : parentPath + '/' + cleanChild;
          return res || '/';
        },

        // Validate if file operation is allowed
        validateFileOperation: (path) => {
          if (!path || !path.startsWith(':')) return false;
          const normalized = path.replace(/\/+$/g, '');
          const colonCount = (normalized.match(/:/g) || []).length;
          return !(colonCount === 3 && normalized.endsWith(':'));
        },

        // Filter list results to show only virtual drive items
        // Exception: if requestPath is '/', don't filter (show all drives)
        filterListResults: (items, requestPath) => {
          if (!items || !Array.isArray(items)) return items;
          if (requestPath === '/') return items;
          return items.filter(item => item.path && item.path.startsWith(':'));
        },

        // Get parent folder path (one level up)
        getParentFolder: (folder) => {
          if (!folder) return null;

          // Remove trailing slashes
          const normalized = folder.replace(/\/+$/g, '');

          // Find last /
          const lastSlashIndex = normalized.lastIndexOf('/');

          if (lastSlashIndex <= 0) return null;

          // Return parent path
          return normalized.substring(0, lastSlashIndex);
        },

        // Build navigation URL for a folder path
        buildNavigationUrl: (folderPath) => {
          const queryParams = MwdHelpers.fileItemQueryParams({
            path: folderPath,
            isFolder: true
          });

          const queryString = Object.entries(queryParams || {})
            .filter(([key, value]) => value)
            .map(([key, value]) =>
              `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
            )
            .join('&');

          return queryString ? `/my-files?${queryString}` : '/my-files';
        },

        // --- Get the file extension from the full file path
        getFileExtension: (filePath) =>
          filePath?.includes(".")
            ? filePath?.split(".").pop()?.toLowerCase()
            : undefined,

        // --- Get the file/folder name from the full path
        // Handles two forms:
        // 1) Drive-prefixed paths like ":sh:Projects:/" -> returns "Projects"
        // 2) Drive-prefixed paths with additional path ":sh:Projects:/folder/file.txt" -> returns "file.txt"
        // 3) Regular paths "/a/b/file.txt" -> returns "file.txt"
        getFileName: (filePath) => {
          if (!filePath) return '';
          if (filePath.startsWith(':')) {
            const segs = filePath.split(':');
            const driveName = segs[2] || '';
            const after = segs[3] || '';
            const cleanAfter = after.replace(/^\/+/g, '').replace(/\/+$|^\/+$|\/+$/g, '');
            if (!cleanAfter) return driveName;
            const parts = cleanAfter.split('/');
            return parts[parts.length - 1] || driveName;
          }
          const normalized = filePath.replace(/\/+$/g, '');
          const lastSlash = normalized.lastIndexOf('/');
          return lastSlash >= 0 ? normalized.substring(lastSlash + 1) : normalized;
        },

        // --- Get the object property by path (e.g. "a.b[0].c")
        getPropertyByPath: (object, path) => {
          if (!object || typeof object !== "object") {
            return undefined;
          }

          if (!path || typeof path !== "string") {
            return undefined;
          }

          const pathArray = path
            .replace(/\[(\d+)\]/g, ".$1")
            .split(".")
            .filter(Boolean);

          let result = object;

          for (const key of pathArray) {
            if (result == null || typeof result !== "object") {
              return undefined;
            }
            result = result[key];
          }

          return result;
        },

        sortFiles: (files, sortBy, direction) => {
          if (!files) return [];
          if (sortBy === undefined) return files.slice();
          const sorted = files.slice().toSorted((a, b) => {
            const compMin = direction === "ascending" ? -1 : 1;
            const compMax = direction === "ascending" ? 1 : -1;

            if (sortBy === "type") {
              const _a = MwdHelpers.getFileExtension(a.name) || "";
              const _b = MwdHelpers.getFileExtension(b.name) || "";
              return _a > _b ? compMax : _b > _a ? compMin : 0;
            } else {
              return MwdHelpers.getPropertyByPath(a, sortBy) >
                MwdHelpers.getPropertyByPath(b, sortBy)
                ? compMax
                : MwdHelpers.getPropertyByPath(b, sortBy) >
                  MwdHelpers.getPropertyByPath(a, sortBy)
                ? compMin
                : 0;
            }
          });
          return sorted;
        },
        // Format items array into a human-readable summary:
        // - single file: file "filename"
        // - single folder: folder "foldername"
        // - multiple items: "N items"
        // Uses `getFileName` transformation to derive display name from drive-prefixed paths.
        formatItemsSummary: (items) => {
          if (!items || !Array.isArray(items) || items.length === 0) return `0 items`;
          if (items.length === 1) {
            var it = items[0];
            var kind = (it && it.isFolder) ? `folder` : `file`;
            var name = '';
            if (it && it.path) {
              name = MwdHelpers.getFileName(it.path) || '';
            } else if (it && it.name) {
              name = it.name;
            }
            return `${kind} "${name}"`;
          }
          return `${items.length} items`;
        },
        // Set a property on the window object by name
        setWindowProperty: (name, value) => {
          window[name] = value;
        },
        // (getter removed - use direct window access)
        // (array-push helper removed - use direct window access)
      };

      // Global event bus using window.postMessage
      // Source: https://docs.xmlui.org/components/MessageListener
      window.publishTopic = (type, payload) => {
        // Deep clone to strip Proxy wrappers and make data structured-clonable
        const cloneablePayload = payload ? JSON.parse(JSON.stringify(payload)) : undefined;
        window.postMessage({ type, payload: cloneablePayload }, '*');
      };
    </script>
  </body>
</html>
